package processors

import (
	"context"
	"fmt"
	"net/url"

	builder "github.com/aporeto-se/enforcerd-kube-builder"
	prisma_api "github.com/aporeto-se/prisma-sdk-go-v2/api"
	prisma_types "github.com/aporeto-se/prisma-sdk-go-v2/types"
	"github.com/hashicorp/go-multierror"
	"go.uber.org/zap"
	k8smetav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"

	"github.com/aporeto-se/cloud-operator/common/types"
)

// KubeProcessor Kubernetes processor
type KubeProcessor struct {
	name                string
	prismaClient        *prisma_api.Client
	cloudOperatorConfig *types.CloudOperatorConfig

	protectConfig   bool
	importLabel     string
	prismaAPIConfig *prisma_types.PrismaConfig

	Endpoint                   string
	CidrBlocks                 []string
	KubernetesClientset        *kubernetes.Clientset
	KubernetesDaemonsetBuilder *builder.Builder
}

// NewKubeProcessor returns new entity instance
func NewKubeProcessor(name string, cloudOperatorConfig *types.CloudOperatorConfig, prismaClient *prisma_api.Client) (*KubeProcessor, error) {

	zap.L().Debug("entering NewKubeClusterProcessor")

	var errors *multierror.Error

	if name == "" {
		errors = multierror.Append(errors, fmt.Errorf("name is required"))
	}

	if cloudOperatorConfig == nil {
		errors = multierror.Append(errors, fmt.Errorf("entity CloudOperatorConfig is required"))
	}

	if prismaClient == nil {
		errors = multierror.Append(errors, fmt.Errorf("entity PrismaClient is required"))
	}

	err := errors.ErrorOrNil()
	if err != nil {
		zap.L().Debug("returning Process with error(s)")
		return nil, err
	}

	protectConfig := false

	if !cloudOperatorConfig.DisableProtectConfig {
		protectConfig = true
	}

	return &KubeProcessor{
		name:                name,
		cloudOperatorConfig: cloudOperatorConfig,
		prismaClient:        prismaClient,
		importLabel:         importLabel + "-" + name,
		protectConfig:       protectConfig,
	}, nil
}

// SetEndpoint sets attribute and returns self
func (t *KubeProcessor) SetEndpoint(endpoint string) *KubeProcessor {
	t.Endpoint = endpoint
	return t
}

// SetCidrBlocks sets attribute and returns self
func (t *KubeProcessor) SetCidrBlocks(cidrBlocks []string) *KubeProcessor {
	t.CidrBlocks = cidrBlocks
	return t
}

// AddCidrBlocks adds attribute and returns self
func (t *KubeProcessor) AddCidrBlocks(cidrBlocks ...string) *KubeProcessor {
	t.CidrBlocks = append(t.CidrBlocks, cidrBlocks...)
	return t
}

// SetKubernetesClientset sets entity and returns self
func (t *KubeProcessor) SetKubernetesClientset(kubernetesClientset *kubernetes.Clientset) *KubeProcessor {
	t.KubernetesClientset = kubernetesClientset
	return t
}

// SetKubernetesDaemonsetBuilder sets entity and returns self
func (t *KubeProcessor) SetKubernetesDaemonsetBuilder(kubernetesDaemonsetBuilder *builder.Builder) *KubeProcessor {
	t.KubernetesDaemonsetBuilder = kubernetesDaemonsetBuilder
	return t
}

func (t *KubeProcessor) initPrismaAPIConfig() {
	if t.prismaAPIConfig == nil {
		t.prismaAPIConfig = prisma_types.NewPrismaConfig(t.importLabel)
	}
}

// Process process Kube and Prisma. Returns error on error.
func (t *KubeProcessor) Process(ctx context.Context) error {

	err := t.addKubeAPIConfig()
	if err != nil {
		zap.L().Debug("returning Process with error(s)")
		return err
	}

	err = t.addKubeDNSNet(ctx)
	if err != nil {
		zap.L().Debug("returning Process with error(s)")
		return err
	}

	err = t.addKubeAPINet()
	if err != nil {
		zap.L().Debug("returning Process with error(s)")
		return err
	}

	if t.prismaAPIConfig != nil {
		zap.L().Debug(fmt.Sprintf("Importing Prisma API config for %s", t.importLabel))
		err = t.prismaClient.ImportPrismaConfig(ctx, t.prismaAPIConfig)
		if err != nil {
			zap.L().Debug("returning Process with error(s)")
			return err
		}
	} else {
		zap.L().Debug(fmt.Sprintf("No Prisma API config for %s", t.importLabel))
	}

	err = t.installEnforcer(ctx)
	if err != nil {
		zap.L().Debug("returning Process with error(s)")
		return err
	}

	zap.L().Debug("returning Process")
	return nil
}

func (t *KubeProcessor) addKubeAPIConfig() error {

	zap.L().Debug("entering addKubeAPIConfig")

	if !t.cloudOperatorConfig.HasOp(types.OpKubeAPINet) {
		zap.L().Debug("returing addKubeAPIConfig option is disabled")
		return nil
	}

	t.initPrismaAPIConfig()

	if t.Endpoint == "" {
		zap.L().Debug("returing addKubeAPIConfig with error(s)")
		return fmt.Errorf("endpoint is required")
	}

	u, _ := url.Parse(t.Endpoint)
	t.prismaAPIConfig.AddExternalnetwork(
		prisma_types.NewExternalnetwork("Kube API").
			SetDescription("auto-generated by Cloud Operator").
			SetProtected(t.protectConfig).AddEntry(u.Host).
			SetPropagate(true))

	zap.L().Debug("returing addKubeAPIConfig")
	return nil
}

func (t *KubeProcessor) addKubeDNSNet(ctx context.Context) error {

	zap.L().Debug("entering addKubeDNSNet")

	if !t.cloudOperatorConfig.HasOp(types.OpKubeDNSNet) {
		zap.L().Debug("returing addKubeDNSNet option is disabled")
		return nil
	}

	if t.KubernetesClientset == nil {
		zap.L().Debug("returing addKubeDNSNet with error(s)")
		return fmt.Errorf("kubernetesClientset is required")
	}

	t.initPrismaAPIConfig()

	service, err := t.KubernetesClientset.CoreV1().Services("kube-system").Get(ctx, "kube-dns", k8smetav1.GetOptions{})
	if err != nil {
		zap.L().Debug("returing addKubeDNSNet with error(s)")
		return err
	}
	ip := service.Spec.ClusterIP
	if ip == "" {
		zap.L().Debug("returing addKubeDNSNet with error(s)")
		return fmt.Errorf("unable to determine DNS IP")
	}

	zap.L().Debug(fmt.Sprintf("Creating external network for kube dns (%s) for cluster %s", ip, t.name))
	t.prismaAPIConfig.AddExternalnetwork(
		prisma_types.NewExternalnetwork("Kube DNS").
			SetDescription("auto-generated by Cloud Operator").
			SetProtected(t.protectConfig).
			SetPropagate(true).
			AddEntry(ip))

	zap.L().Debug("returing addKubeDNSNet")
	return nil
}

func (t *KubeProcessor) addKubeAPINet() error {

	zap.L().Debug("entering addKubeAPINet")

	if !t.cloudOperatorConfig.HasOp(types.OpKubeAPINet) {
		zap.L().Debug("returing addKubeAPINet option is disabled")
		return nil
	}

	t.initPrismaAPIConfig()

	if t.CidrBlocks == nil {
		zap.L().Debug("returing addKubeAPINet with error(s)")
		return fmt.Errorf("cluster has no CIDR blocks specified")
	}

	if len(t.CidrBlocks) <= 0 {
		zap.L().Debug("returing addKubeAPINet with error(s)")
		return fmt.Errorf("cluster has no CIDR blocks specified")
	}

	t.prismaAPIConfig.AddExternalnetwork(
		prisma_types.NewExternalnetwork("cluster networks").
			SetDescription("auto-generated by Cloud Operator").
			SetProtected(t.protectConfig).SetEntries(t.CidrBlocks))

	zap.L().Debug("returing addKubeAPINet")
	return nil
}

func (t *KubeProcessor) installEnforcer(ctx context.Context) error {

	zap.L().Debug("entering installEnforcer")

	if !t.cloudOperatorConfig.HasOp(types.OpKubeEnforcer) {
		zap.L().Debug("returing installEnforcer option is disabled")
		return nil
	}

	if t.KubernetesClientset == nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return fmt.Errorf("kubernetesClientset is required")
	}

	if t.KubernetesDaemonsetBuilder == nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return fmt.Errorf("kubernetesDaemonsetBuilder is required")
	}

	daemonset := t.KubernetesDaemonsetBuilder.Build()

	zap.L().Debug(fmt.Sprintf("Applying Kubernetes namespace config to Cluster %s", t.name))
	_, err := t.KubernetesClientset.CoreV1().Namespaces().Apply(ctx, daemonset.Namespace, k8smetav1.ApplyOptions{
		FieldManager: "cloud-operator",
	})
	if err != nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return err
	}

	zap.L().Debug(fmt.Sprintf("Applying Kubernetes Cluster Role config to Cluster %s", t.name))
	_, err = t.KubernetesClientset.RbacV1().ClusterRoles().Apply(ctx, daemonset.ClusterRole, k8smetav1.ApplyOptions{
		FieldManager: "cloud-operator",
	})
	if err != nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return err
	}

	zap.L().Debug(fmt.Sprintf("Applying Kubernetes Cluster Role Binding config to Cluster %s", t.name))
	_, err = t.KubernetesClientset.RbacV1().ClusterRoleBindings().Apply(ctx, daemonset.ClusterRoleBinding, k8smetav1.ApplyOptions{
		FieldManager: "cloud-operator",
	})
	if err != nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return err
	}

	zap.L().Debug(fmt.Sprintf("Applying Kubernetes Service Account config to Cluster %s", t.name))
	_, err = t.KubernetesClientset.CoreV1().ServiceAccounts("aporeto").Apply(ctx, daemonset.ServiceAccount, k8smetav1.ApplyOptions{
		FieldManager: "cloud-operator",
	})
	if err != nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return err
	}

	zap.L().Debug(fmt.Sprintf("Applying Kubernetes Daemonset config to Cluster %s", t.name))
	_, err = t.KubernetesClientset.AppsV1().DaemonSets("aporeto").Apply(ctx, daemonset.DaemonSet, k8smetav1.ApplyOptions{
		FieldManager: "cloud-operator",
	})
	if err != nil {
		zap.L().Debug("returing installEnforcer with error(s)")
		return err
	}

	zap.L().Debug("returing installEnforcer")
	return nil
}
